{"version":3,"file":"promiseful.min.js","sources":["../../src/api/series.js","../../src/api/parallelLimit.js","../../src/api/waterfall.js","../../src/api/forever.js","../../src/api/until.js","../../src/api/whilst.js","../../src/api/relay.js","../../src/api/functions/applyEach.js","../../src/api/functions/applyEachOf.js","../../src/api/functions/applyMap.js","../../src/api/functions/applyMapOf.js","../../src/api/functions/times.js","../../src/api/collections/each.js","../../src/api/collections/eachOf.js","../../src/api/collections/map.js","../../src/api/collections/mapOf.js","../../src/api/collections/filter.js","../../src/api/collections/groupBy.js","../../src/api/collections/every.js","../../src/api/conditionalRace.js","../../src/api/collections/some.js","../../src/utils/collection.js","../../src/api/core.js","../../src/api/kernel.js","../../src/api/functions/collector.js","../../src/api/index.js"],"sourcesContent":["import core from './core';\n\nexport default function series(fns) {\n  function reducer(acc, fn) {\n    return new core.Promise((resolve, reject) => {\n      fn()\n      .then((val) => {\n        acc.push(val);\n        resolve(acc);\n      })\n      .catch(reject);\n    });\n  }\n\n  return core.reduce(fns, reducer, []);\n}\n","import utils from '../utils/index';\nimport core from './core';\nimport series from './series';\n\nexport default function parallelLimit(fns, limit = 0) {\n  const funcs = utils.collection.arrayize(fns);\n  if (limit <= 0 || limit >= funcs.length) {\n    return core.all(funcs);\n  }\n\n  const funcsList = utils.collection.chunk(funcs, limit)\n    .map(c => (() => core.all(c)));\n\n  return series(funcsList)\n    .then(utils.collection.flatten);\n}\n","import core from './core';\n\nexport default function waterfall(fns, initVal) {\n  function reducer(acc, fn) {\n    return new core.Promise((resolve, reject) => {\n      fn(acc)\n      .then(resolve)\n      .catch(reject);\n    });\n  }\n\n  return core.reduce(fns, reducer, initVal);\n}\n","import core from './core';\n\nexport default function forver(fn) {\n  return core.loop(fn, () => false);\n}\n","import core from './core';\n\nexport default function until(test, fn, ...initValue) {\n  return core.loop(fn, v => test(v), ...initValue);\n}\n","import core from './core';\n\nexport default function whilst(test, fn, ...initValue) {\n  return core.loop(fn, v => !test(v), ...initValue);\n}\n","import core from './core';\n\nexport default function relay(fns) {\n  function reducer(acc, fn) {\n    return new core.Promise((resolve, reject) => {\n      fn()\n      .then(resolve)\n      .catch((reason) => {\n        acc.push(reason);\n        reject(acc);\n      });\n    });\n  }\n\n  return core.reduceRejects(fns, reducer, []);\n}\n","import collector from './collector';\nimport utils from '../../utils/index';\n\nexport default function applyMap(fns, ...args) {\n  const funcs = utils.collection.arrayize(fns)\n    .map(f => f.bind(null, ...args));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(() => undefined);\n}\n","import collector from './collector';\n\nexport default function applyEachOf(data, ...args) {\n  const keys = Object.keys(data);\n  const funcs = keys.map(d => data[d].bind(null, ...args));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(() => undefined);\n}\n","import collector from './collector';\nimport utils from '../../utils/index';\n\nexport default function applyMap(fns, ...args) {\n  const funcs = utils.collection.arrayize(fns)\n    .map(f => f.bind(null, ...args));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel();\n}\n","import collector from './collector';\n\nexport default function applyMapOf(data, ...args) {\n  const keys = Object.keys(data);\n  const funcs = keys.map(d => data[d].bind(null, ...args));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals =>\n    keys.reduce((acc, key, idx) => {\n      acc[key] = vals[idx];\n      return acc;\n    },\n    {}),\n  );\n}\n","import collector from './collector';\n\nexport default function times(n, fn) {\n  const funcs = [];\n  for (let i = 0; i < n; i += 1) {\n    funcs.push(fn.bind(null, i));\n  }\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel();\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function each(data, fn) {\n  const funcs = utils.collection.arrayize(data)\n    .map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(() => undefined);\n}\n","import collector from '../functions/collector';\n\nexport default function eachOf(data, fn) {\n  const funcs = Object.keys(data)\n    .map(d => fn.bind(null, data[d], d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(() => undefined);\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function map(data, fn) {\n  const funcs = utils.collection.arrayize(data)\n    .map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel();\n}\n","import collector from '../functions/collector';\n\nexport default function mapOf(data, fn) {\n  const keys = Object.keys(data);\n  const funcs = keys.map(d => fn.bind(null, data[d], d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals =>\n    keys.reduce((acc, key, idx) => {\n      acc[key] = vals[idx];\n      return acc;\n    },\n    {}),\n  );\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function filter(data, fn) {\n  const arrData = utils.collection.arrayize(data);\n  const funcs = arrData.map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals =>\n    vals.reduce((acc, val, idx) => {\n      if (val) {\n        acc.push(arrData[idx]);\n      }\n      return acc;\n    },\n    []),\n  );\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function groupBy(data, fn) {\n  const arrData = utils.collection.arrayize(data);\n  const funcs = arrData.map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals =>\n    vals.reduce((acc, val, idx) => {\n      if (!(val in acc)) {\n        acc[val] = [];\n      }\n      acc[val].push(arrData[idx]);\n      return acc;\n    },\n    {}),\n  );\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function every(data, fn) {\n  const arrData = utils.collection.arrayize(data);\n  const funcs = arrData.map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals => vals.every(e => e));\n}\n","import core from './core';\nimport utils from '../utils/index';\n\nexport default function conditionalRace(fns, test, min = 1) {\n  const funcs = utils.collection.arrayize(fns);\n\n  return new core.Promise((resolve, reject) => {\n    let len = funcs.length;\n    let passed = 0;\n    let done = false;\n\n    function fulfilled(val) {\n      len -= 1;\n      if (done) {\n        return;   // Resolved/Rejected already\n      }\n\n      if (test(val)) {\n        passed += 1;\n        if (passed === min) {\n          done = true;\n          resolve(val);\n          return;\n        }\n      }\n\n      if (len === 0) {\n        // < min passed\n        done = true;\n        resolve(false);\n      }\n    }\n\n    function rejected(reason) {\n      len -= 1;\n      if (done) {\n        return;   // Resolved/Rejected already\n      }\n\n      done = true;\n      reject(reason);\n    }\n\n    // Call all functions individually and simultaneously\n    funcs.forEach(fn => fn().then(fulfilled, rejected));\n  });\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\nimport conditionalRace from '../conditionalRace';\n\nexport default function some(data, fn) {\n  const arrData = utils.collection.arrayize(data);\n  const funcs = arrData.map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals => vals.some(e => e))\n    .attachMethod('race', (fns => conditionalRace(fns, b => b)));\n}\n","export default class Collection {\n  static arrayize(coll) {\n    return Array.isArray(coll) ? coll : Array.from(coll);\n  }\n\n  static chunk(coll, n) {\n    const array = Collection.arrayize(coll);\n    if (n <= 0 || n >= array.length) {\n      return [array];\n    }\n\n    const ret = [];\n    for (let i = 0; i < array.length; i += n) {\n      ret.push(array.slice(i, i + n));\n    }\n\n    return ret;\n  }\n\n  static flatten(arrays) {\n    return [].concat(...arrays);\n  }\n}\n","import utils from '../utils/index';\n\nclass Promiseful {\n\n  constructor(promise) {\n    this.Promise = promise;\n  }\n\n  fulfil(val) {\n    if (typeof val === 'function') {\n      return val;\n    }\n\n    // Is this a Promise?\n    if (typeof val === 'object'\n      && val.then\n      && typeof val.then === 'function') {\n      return () => val;\n    }\n\n    // Anything else, wrap the value into a promise nd wrap into a function\n    return () => this.Promise.resolve(val);\n  }\n\n  promise(...promise) {\n    if (promise.length > 0) {\n      this.Promise = promise[0];\n    }\n\n    return this.Promise;\n  }\n\n  promisify(fn) {\n    const self = this;\n\n    return (...args) => (\n      new self.Promise((resolve, reject) => {\n        args.push((err, ...result) => {\n          if (err) {\n            reject(err);\n          } else if (result.length <= 1) {\n            resolve(...result);\n          } else {\n            resolve(result);\n          }\n        });\n\n        fn(...args);\n      })\n    );\n  }\n\n  all(funcs) {\n    return this.Promise.all(\n      utils.collection.arrayize(funcs)\n        .map(a => this.fulfil(a))\n        .map(a => a()),\n    );\n  }\n\n  race(fns) {\n    const funcs = utils.collection.arrayize(fns);\n    if (funcs.length < 1) {\n      return this.Promise.resolve(null);\n    }\n\n    return this.Promise.race(funcs.map(a => this.fulfil(a)).map(a => a()));\n  }\n\n  reduce(fns, reducer, inital) {\n    const funcs = utils.collection.arrayize(fns);\n    const self = this;\n\n    return new this.Promise((resolve, reject) => {\n      function next(idx, acc) {\n        if (idx >= funcs.length) {\n          resolve(acc);\n          return;\n        }\n\n        const p = self.fulfil(funcs[idx]);\n        reducer(acc, p, idx)\n        .then(next.bind(this, idx + 1))\n        .catch(reject);\n      }\n\n      next(0, inital);\n    });\n  }\n\n  reduceRejects(fns, reducer, inital) {\n    const funcs = utils.collection.arrayize(fns);\n    const self = this;\n\n    return new this.Promise((resolve, reject) => {\n      function next(idx, acc) {\n        if (idx >= funcs.length) {\n          reject(acc);\n          return;\n        }\n\n        const p = self.fulfil(funcs[idx]);\n        reducer(acc, p, idx)\n        .then(resolve)\n        .catch(next.bind(this, idx + 1));\n      }\n\n      next(0, inital);\n    });\n  }\n\n  loop(fn, breaker, ...initValue) {\n    const func = this.fulfil(fn);\n\n    return new this.Promise((resolve, reject) => {\n      function next() {\n        func()\n        .then((v) => {\n          if (breaker(v)) {\n            resolve(v);\n          } else {\n            next();\n          }\n        })\n        .catch(reject);\n      }\n\n      if (initValue.length > 0 && breaker(...initValue)) {\n        resolve(...initValue);\n        return;\n      }\n\n      next();\n    });\n  }\n}\n\nconst instance = new Promiseful((typeof Promise !== 'undefined') ? Promise : null);\nexport default instance;\n","import core from './core';\nimport series from './series';\nimport parallelLimit from './parallelLimit';\nimport relay from './relay';\n\nconst Kernel = {\n\n  // core\n  all: core.all.bind(core),\n  race: core.race.bind(core),\n\n  // other\n  series,\n  parallel: core.all.bind(core),\n  parallelLimit,\n  relay,\n};\n\nexport default Kernel;\n","import kernel from '../kernel';\n\nclass Functions {\n  constructor(coll) {\n    this.coll = coll;\n  }\n\n\n  attachMethod(name, fn, ...thens) {\n    // this[name] = fn.bind(null, this.coll);\n    this[name] = (...args) => {\n      const m = fn(this.coll, ...args);\n      return thens.reduce((acc, t) => acc.then(t), m);\n    };\n\n    return this;\n  }\n\n  attachKernel(...thens) {\n    Object.keys(kernel)\n      .forEach(f => this.attachMethod(f, kernel[f], ...thens));\n    return this;\n  }\n}\n\nif (typeof Symbol !== 'undefined') {\n  Functions.prototype[Symbol.iterator] = function SymbolIterator() {\n    let idx = 0;\n    const coll = this.coll;\n    return {\n      next() {\n        if (idx >= coll.length) {\n          return {\n            done: true,\n          };\n        }\n        const value = coll[idx];\n        idx += 1;\n\n        return {\n          done: idx > coll.length,\n          value,\n        };\n      },\n    };\n  };\n}\n\nconst collector = {\n  Functions,\n};\n\n\nexport default collector;\n","import core from './core';\nimport series from './series';\nimport parallelLimit from './parallelLimit';\nimport waterfall from './waterfall';\nimport forever from './forever';\nimport until from './until';\nimport whilst from './whilst';\nimport relay from './relay';\n\nimport applyEach from './functions/applyEach';\nimport applyEachOf from './functions/applyEachOf';\nimport applyMap from './functions/applyMap';\nimport applyMapOf from './functions/applyMapOf';\nimport times from './functions/times';\n\nimport each from './collections/each';\nimport eachOf from './collections/eachOf';\nimport map from './collections/map';\nimport mapOf from './collections/mapOf';\nimport filter from './collections/filter';\nimport groupBy from './collections/groupBy';\nimport every from './collections/every';\nimport some from './collections/some';\n\nconst Promiseful = {\n\n  // core\n  promisify: core.promisify.bind(core),\n  all: core.all.bind(core),\n  race: core.race.bind(core),\n  reduce: core.reduce.bind(core),\n\n  // other\n  series,\n  parallel: core.all.bind(core),\n  parallelLimit,\n  relay,\n  waterfall,\n\n  // aliases\n  inject: core.reduce.bind(core),\n  fold: core.reduce.bind(core),\n  tryEach: relay,\n\n  // Collections\n  each,\n  eachOf,\n  map,\n  mapOf,\n  filter,\n  groupBy,\n  every,\n  some,\n\n  // Collection - aliases\n  mapValues: mapOf,\n\n  // Functions\n  applyEach,\n  applyEachOf,\n  applyMap,\n  applyMapOf,\n  times,\n\n  // Loops\n  forever,\n  until,\n  whilst,\n};\n\nPromiseful.promise = (P) => {\n  if (P) {\n    core.promise(P);\n    return Promiseful;\n  }\n\n  return core.promise();\n};\n\nexport default Promiseful;\n\n// export {\n//     core.promise as promise,\n//     core.all as all,\n//     core.race as race,\n//     core.reduce as reduce,\n//     core.parallelLimit as parallelLimit,\n//\n//     series as series,\n//     parallel as parallel,\n//     waterfall as waterfall,\n//\n//     all as every,\n//     reduce as inject,\n//     reduce as foldl\n// };\n"],"names":["series","fns","reducer","acc","fn","core","Promise","resolve","reject","then","val","push","catch","reduce","parallelLimit","limit","funcs","utils","collection","arrayize","length","all","chunk","map","c","flatten","waterfall","initVal","forver","loop","until","test","initValue","v","whilst","relay","reason","reduceRejects","applyMap","args","f","bind","collector","Functions","attachKernel","applyEachOf","data","Object","keys","d","applyMapOf","key","idx","vals","times","n","i","each","eachOf","mapOf","filter","arrData","groupBy","every","e","conditionalRace","min","fulfilled","done","len","rejected","passed","forEach","some","attachMethod","b","coll","Array","isArray","from","array","Collection","ret","slice","arrays","concat","instance","promise","_this","arguments","this","self","err","result","_this2","fulfil","a","race","_this3","inital","next","p","breaker","func","Kernel","name","thens","m","t","kernel","Symbol","prototype","iterator","value","Promiseful","promisify","P"],"mappings":"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"}