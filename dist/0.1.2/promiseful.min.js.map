{"version":3,"file":"promiseful.min.js","sources":["../../src/api/series.js","../../src/api/parallelLimit.js","../../src/api/waterfall.js","../../src/api/forever.js","../../src/api/until.js","../../src/api/whilst.js","../../src/api/relay.js","../../src/api/functions/applyEach.js","../../src/api/functions/times.js","../../src/api/collections/each.js","../../src/api/collections/eachOf.js","../../src/api/collections/map.js","../../src/api/collections/mapOf.js","../../src/api/collections/filter.js","../../src/api/collections/groupBy.js","../../src/api/collections/every.js","../../src/api/conditionalRace.js","../../src/api/collections/some.js","../../src/utils/collection.js","../../src/api/core.js","../../src/api/kernel.js","../../src/api/functions/collector.js","../../src/api/index.js"],"sourcesContent":["import core from './core';\n\nexport default function series(fns) {\n  function reducer(acc, fn) {\n    return new core.Promise((resolve, reject) => {\n      fn()\n      .then((val) => {\n        acc.push(val);\n        resolve(acc);\n      })\n      .catch(reject);\n    });\n  }\n\n  return core.reduce(fns, reducer, []);\n}\n","import utils from '../utils/index';\nimport core from './core';\nimport series from './series';\n\nexport default function parallelLimit(fns, limit = 0) {\n  const funcs = utils.collection.arrayize(fns);\n  if (limit <= 0 || limit >= funcs.length) {\n    return core.all(funcs);\n  }\n\n  const funcsList = utils.collection.chunk(funcs, limit)\n    .map(c => (() => core.all(c)));\n\n  return series(funcsList)\n    .then(utils.collection.flatten);\n}\n","import core from './core';\n\nexport default function waterfall(fns, initVal) {\n  function reducer(acc, fn) {\n    return new core.Promise((resolve, reject) => {\n      fn(acc)\n      .then(resolve)\n      .catch(reject);\n    });\n  }\n\n  return core.reduce(fns, reducer, initVal);\n}\n","import core from './core';\n\nexport default function forver(fn) {\n  return core.loop(fn, () => false);\n}\n","import core from './core';\n\nexport default function until(test, fn, ...initValue) {\n  return core.loop(fn, v => test(v), ...initValue);\n}\n","import core from './core';\n\nexport default function whilst(test, fn, ...initValue) {\n  return core.loop(fn, v => !test(v), ...initValue);\n}\n","import core from './core';\n\nexport default function relay(fns) {\n  function reducer(acc, fn) {\n    return new core.Promise((resolve, reject) => {\n      fn()\n      .then(resolve)\n      .catch((reason) => {\n        acc.push(reason);\n        reject(acc);\n      });\n    });\n  }\n\n  return core.reduceRejects(fns, reducer, []);\n}\n","import collector from './collector';\nimport utils from '../../utils/index';\n\nexport default function applyEach(fns, ...args) {\n  const funcs = utils.collection.arrayize(fns)\n    .map(f => f.bind(null, ...args));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel();\n}\n","import collector from './collector';\n\nexport default function times(n, fn) {\n  const funcs = [];\n  for (let i = 0; i < n; i += 1) {\n    funcs.push(fn.bind(null, i));\n  }\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel();\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function each(data, fn) {\n  const funcs = utils.collection.arrayize(data)\n    .map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(() => undefined);\n}\n","import collector from '../functions/collector';\n\nexport default function eachOf(data, fn) {\n  const funcs = Object.keys(data)\n    .map(d => fn.bind(null, data[d], d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(() => undefined);\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function map(data, fn) {\n  const funcs = utils.collection.arrayize(data)\n    .map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel();\n}\n","import collector from '../functions/collector';\n\nexport default function mapOf(data, fn) {\n  const keys = Object.keys(data);\n  const funcs = keys.map(d => fn.bind(null, data[d], d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals =>\n    keys.reduce((acc, key, idx) => {\n      acc[key] = vals[idx];\n      return acc;\n    },\n    {}),\n  );\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function filter(data, fn) {\n  const arrData = utils.collection.arrayize(data);\n  const funcs = arrData.map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals =>\n    vals.reduce((acc, val, idx) => {\n      if (val) {\n        acc.push(arrData[idx]);\n      }\n      return acc;\n    },\n    []),\n  );\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function groupBy(data, fn) {\n  const arrData = utils.collection.arrayize(data);\n  const funcs = arrData.map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals =>\n    vals.reduce((acc, val, idx) => {\n      if (!(val in acc)) {\n        acc[val] = [];\n      }\n      acc[val].push(arrData[idx]);\n      return acc;\n    },\n    {}),\n  );\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\n\nexport default function every(data, fn) {\n  const arrData = utils.collection.arrayize(data);\n  const funcs = arrData.map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals => vals.every(e => e));\n}\n","import core from './core';\nimport utils from '../utils/index';\n\nexport default function conditionalRace(fns, test, min = 1) {\n  const funcs = utils.collection.arrayize(fns);\n\n  return new core.Promise((resolve, reject) => {\n    let len = funcs.length;\n    let passed = 0;\n    let done = false;\n\n    function fulfilled(val) {\n      len -= 1;\n      if (done) {\n        return;   // Resolved/Rejected already\n      }\n\n      if (test(val)) {\n        passed += 1;\n        if (passed === min) {\n          done = true;\n          resolve(val);\n          return;\n        }\n      }\n\n      if (len === 0) {\n        // < min passed\n        done = true;\n        resolve(false);\n      }\n    }\n\n    function rejected(reason) {\n      len -= 1;\n      if (done) {\n        return;   // Resolved/Rejected already\n      }\n\n      done = true;\n      reject(reason);\n    }\n\n    // Call all functions individually and simultaneously\n    funcs.forEach(fn => fn().then(fulfilled, rejected));\n  });\n}\n","import collector from '../functions/collector';\nimport utils from '../../utils/index';\nimport conditionalRace from '../conditionalRace';\n\nexport default function some(data, fn) {\n  const arrData = utils.collection.arrayize(data);\n  const funcs = arrData.map(d => fn.bind(null, d));\n\n  const coll = new collector.Functions(funcs);\n  return coll.attachKernel(vals => vals.some(e => e))\n    .attachMethod('race', (fns => conditionalRace(fns, b => b)));\n}\n","export default class Collection {\n  static arrayize(coll) {\n    return Array.isArray(coll) ? coll : Array.from(coll);\n  }\n\n  static chunk(coll, n) {\n    const array = Collection.arrayize(coll);\n    if (n <= 0 || n >= array.length) {\n      return [array];\n    }\n\n    const ret = [];\n    for (let i = 0; i < array.length; i += n) {\n      ret.push(array.slice(i, i + n));\n    }\n\n    return ret;\n  }\n\n  static flatten(arrays) {\n    return [].concat(...arrays);\n  }\n}\n","import utils from '../utils/index';\n\nclass Promiseful {\n\n  constructor(promise) {\n    this.Promise = promise;\n  }\n\n  fulfil(val) {\n    if (typeof val === 'function') {\n      return val;\n    }\n\n    // Is this a Promise?\n    if (typeof val === 'object'\n      && val.then\n      && typeof val.then === 'function') {\n      return () => val;\n    }\n\n    // Anything else, wrap the value into a promise nd wrap into a function\n    return () => this.Promise.resolve(val);\n  }\n\n  promise(...promise) {\n    if (promise.length > 0) {\n      this.Promise = promise[0];\n    }\n\n    return this.Promise;\n  }\n\n  promisify(fn) {\n    const self = this;\n\n    return (...args) => (\n      new self.Promise((resolve, reject) => {\n        args.push((err, ...result) => {\n          if (err) {\n            reject(err);\n          } else if (result.length <= 1) {\n            resolve(...result);\n          } else {\n            resolve(result);\n          }\n        });\n\n        fn(...args);\n      })\n    );\n  }\n\n  all(funcs) {\n    return this.Promise.all(\n      utils.collection.arrayize(funcs)\n        .map(a => this.fulfil(a))\n        .map(a => a()),\n    );\n  }\n\n  race(fns) {\n    const funcs = utils.collection.arrayize(fns);\n    if (funcs.length < 1) {\n      return this.Promise.resolve(null);\n    }\n\n    return this.Promise.race(funcs.map(a => this.fulfil(a)).map(a => a()));\n  }\n\n  reduce(fns, reducer, inital) {\n    const funcs = utils.collection.arrayize(fns);\n    const self = this;\n\n    return new this.Promise((resolve, reject) => {\n      function next(idx, acc) {\n        if (idx >= funcs.length) {\n          resolve(acc);\n          return;\n        }\n\n        const p = self.fulfil(funcs[idx]);\n        reducer(acc, p, idx)\n        .then(next.bind(this, idx + 1))\n        .catch(reject);\n      }\n\n      next(0, inital);\n    });\n  }\n\n  reduceRejects(fns, reducer, inital) {\n    const funcs = utils.collection.arrayize(fns);\n    const self = this;\n\n    return new this.Promise((resolve, reject) => {\n      function next(idx, acc) {\n        if (idx >= funcs.length) {\n          reject(acc);\n          return;\n        }\n\n        const p = self.fulfil(funcs[idx]);\n        reducer(acc, p, idx)\n        .then(resolve)\n        .catch(next.bind(this, idx + 1));\n      }\n\n      next(0, inital);\n    });\n  }\n\n  loop(fn, breaker, ...initValue) {\n    const func = this.fulfil(fn);\n\n    return new this.Promise((resolve, reject) => {\n      function next() {\n        func()\n        .then((v) => {\n          if (breaker(v)) {\n            resolve(v);\n          } else {\n            next();\n          }\n        })\n        .catch(reject);\n      }\n\n      if (initValue.length > 0 && breaker(...initValue)) {\n        resolve(...initValue);\n        return;\n      }\n\n      next();\n    });\n  }\n}\n\nconst instance = new Promiseful((typeof Promise !== 'undefined') ? Promise : null);\nexport default instance;\n","import core from './core';\nimport series from './series';\nimport parallelLimit from './parallelLimit';\nimport relay from './relay';\n\nconst Kernel = {\n\n  // core\n  all: core.all.bind(core),\n  race: core.race.bind(core),\n\n  // other\n  series,\n  parallel: core.all.bind(core),\n  parallelLimit,\n  relay,\n};\n\nexport default Kernel;\n","import kernel from '../kernel';\n\nclass Functions {\n  constructor(coll) {\n    this.coll = coll;\n  }\n\n\n  attachMethod(name, fn, ...thens) {\n    // this[name] = fn.bind(null, this.coll);\n    this[name] = (...args) => {\n      const m = fn(this.coll, ...args);\n      return thens.reduce((acc, t) => acc.then(t), m);\n    };\n\n    return this;\n  }\n\n  attachKernel(...thens) {\n    Object.keys(kernel)\n      .forEach(f => this.attachMethod(f, kernel[f], ...thens));\n    return this;\n  }\n}\n\nif (typeof Symbol !== 'undefined') {\n  Functions.prototype[Symbol.iterator] = function SymbolIterator() {\n    let idx = 0;\n    const coll = this.coll;\n    return {\n      next() {\n        if (idx >= coll.length) {\n          return {\n            done: true,\n          };\n        }\n        const value = coll[idx];\n        idx += 1;\n\n        return {\n          done: idx > coll.length,\n          value,\n        };\n      },\n    };\n  };\n}\n\nconst collector = {\n  Functions,\n};\n\n\nexport default collector;\n","import core from './core';\nimport series from './series';\nimport parallelLimit from './parallelLimit';\nimport waterfall from './waterfall';\nimport forever from './forever';\nimport until from './until';\nimport whilst from './whilst';\nimport relay from './relay';\n\nimport applyEach from './functions/applyEach';\nimport times from './functions/times';\n\nimport each from './collections/each';\nimport eachOf from './collections/eachOf';\nimport map from './collections/map';\nimport mapOf from './collections/mapOf';\nimport filter from './collections/filter';\nimport groupBy from './collections/groupBy';\nimport every from './collections/every';\nimport some from './collections/some';\n\nconst Promiseful = {\n\n  // core\n  promisify: core.promisify.bind(core),\n  all: core.all.bind(core),\n  race: core.race.bind(core),\n  reduce: core.reduce.bind(core),\n\n  // other\n  series,\n  parallel: core.all.bind(core),\n  parallelLimit,\n  relay,\n  waterfall,\n\n  // aliases\n  inject: core.reduce.bind(core),\n  fold: core.reduce.bind(core),\n  tryEach: relay,\n\n  // Collections\n  each,\n  eachOf,\n  map,\n  mapOf,\n  filter,\n  groupBy,\n  every,\n  some,\n\n  // Functions\n  applyEach,\n  times,\n  forever,\n  until,\n  whilst,\n};\n\nPromiseful.promise = (P) => {\n  if (P) {\n    core.promise(P);\n    return Promiseful;\n  }\n\n  return core.promise();\n};\n\nexport default Promiseful;\n\n// export {\n//     core.promise as promise,\n//     core.all as all,\n//     core.race as race,\n//     core.reduce as reduce,\n//     core.parallelLimit as parallelLimit,\n//\n//     series as series,\n//     parallel as parallel,\n//     waterfall as waterfall,\n//\n//     all as every,\n//     reduce as inject,\n//     reduce as foldl\n// };\n"],"names":["series","fns","reducer","acc","fn","core","Promise","resolve","reject","then","val","push","catch","reduce","parallelLimit","limit","funcs","utils","collection","arrayize","length","all","chunk","map","c","flatten","waterfall","initVal","forver","loop","until","test","initValue","v","whilst","relay","reason","reduceRejects","applyEach","args","f","bind","collector","Functions","attachKernel","times","n","i","each","data","d","eachOf","Object","keys","mapOf","key","idx","vals","filter","arrData","groupBy","every","e","conditionalRace","min","fulfilled","done","len","rejected","passed","forEach","some","attachMethod","b","coll","Array","isArray","from","array","Collection","ret","slice","arrays","concat","instance","promise","_this","arguments","this","self","err","result","_this2","fulfil","a","race","_this3","inital","next","p","breaker","func","Kernel","name","thens","m","t","kernel","Symbol","prototype","iterator","value","Promiseful","promisify","P"],"mappings":"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"}